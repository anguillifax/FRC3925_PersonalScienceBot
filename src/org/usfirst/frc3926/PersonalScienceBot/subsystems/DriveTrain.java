// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3926.PersonalScienceBot.subsystems;

import org.usfirst.frc3926.PersonalScienceBot.RobotMap;
import org.usfirst.frc3926.PersonalScienceBot.commands.ManualDrive;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class DriveTrain extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController motorLeft = RobotMap.driveTrainMotorLeft;
    SpeedController motorRight = RobotMap.driveTrainMotorRight;
    RobotDrive robotDrive = RobotMap.driveTrainRobotDrive;
    Encoder encoderLeft = RobotMap.driveTrainEncoderLeft;
    Encoder encoderRight = RobotMap.driveTrainEncoderRight;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public void initDefaultCommand() {
    	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    	setDefaultCommand(new ManualDrive());
    	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    	
    	// Set the default command for a subsystem here.
    	//setDefaultCommand(new MySpecialCommand());
    }
    
    /**
     * This method bypasses the straight driving logic.
     * @param left  left motor speed
     * @param right  right motor speed
     */
    public void setRawSpeeds(double left, double right) {
    	robotDrive.setLeftRightMotorOutputs(left, right);
    }
    
	public void resetEncoders() {
		
	}
	
	public double getLeftEncoderDist() {
		return encoderLeft.getDistance();
	}
	
	public double getRightEncoderDist() {
		return encoderRight.getDistance();
	}
    
	
	public void logData() {
		SmartDashboard.putNumber("LeftMotorSpeed", motorLeft.get());
		SmartDashboard.putNumber("RightMotorSpeed", motorRight.get());
		
		SmartDashboard.putBoolean("DriveStraight", driveStraight);
		
		SmartDashboard.putNumber("MaxError", maxError);
	}
	
	
	public void arcadeDriveOLD(double forward, double rotate, boolean squaredInputs) {
		robotDrive.arcadeDrive(forward, rotate, squaredInputs);
	}
    
    
    
    //TESTING
    
    protected boolean driveStraight = false;
	protected double catchUpDivisor = 100; //not used
	
	protected double maxError = 100;
	
	
	/**
	 * A copy of arcade drive that outputs to <method>setMotorSpeeds</method> instead of directly to the DriveTrain.
	 * @param moveValue  Move value
	 * @param rotateValue  Turn value
	 * @param squaredInputs  Enable fine control
	 */
	public void arcadeDrive(double moveValue, double rotateValue, boolean squaredInputs) {
		double leftMotorSpeed;
		double rightMotorSpeed;

		if (squaredInputs) {
			// square the inputs (while preserving the sign) to increase fine control while permitting full power
			if (moveValue >= 0.0) {
				moveValue = (moveValue * moveValue);
			} else {
				moveValue = -(moveValue * moveValue);
			}
			if (rotateValue >= 0.0) {
				rotateValue = (rotateValue * rotateValue);
			} else {
				rotateValue = -(rotateValue * rotateValue);
			}
		}

		if (moveValue > 0.0) {
			if (rotateValue > 0.0) {
				leftMotorSpeed = moveValue - rotateValue;
				rightMotorSpeed = Math.max(moveValue, rotateValue);
			} else {
				leftMotorSpeed = Math.max(moveValue, -rotateValue);
				rightMotorSpeed = moveValue + rotateValue;
			}
		} else {
			if (rotateValue > 0.0) {
				leftMotorSpeed = -Math.max(-moveValue, rotateValue);
				rightMotorSpeed = moveValue + rotateValue;
			} else {
				leftMotorSpeed = moveValue - rotateValue;
				rightMotorSpeed = -Math.max(-moveValue, -rotateValue);
			}
		}
		
		setMotorSpeeds(leftMotorSpeed, rightMotorSpeed);
	}
	
	/**
	 * This method uses logic to try and keep the robot driving perfectly straight.
	 * @param left  Left motor speed
	 * @param right  Right motor speed
	 */
	public void setMotorSpeeds(double left, double right) {
		
		if (left == right) {
			driveStraight = true;
		} else {
			driveStraight = false;
		}
		
		double outLeft = left, 
			outRight = right;
		double error = encoderLeft.getDistance() - encoderRight.getDistance();
		SmartDashboard.putNumber("ErrorValue", error);
		
		maxError = Math.max(maxError, Math.abs(error));
		if (maxError == 0) {maxError = 1;}
		
		if (driveStraight) {
			if (error > 0) {
				outLeft = left - (error / maxError);
			} else if (error < 0) {
				outRight = right - (error / maxError);
			}
			
		}
			robotDrive.setLeftRightMotorOutputs(limit(outLeft), limit(outRight));
		
	}
	
	
	public void setDriveStraight(boolean enable) {
		driveStraight = enable;
	}
	
	
	protected double limit(double input) {
		if (input > 1) {
			return 1;
		} else if (input < -1) {
			return -1;
		} else {
			return input;
		}
		
	}

}

